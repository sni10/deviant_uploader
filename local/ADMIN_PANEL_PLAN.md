# План реализации простой админ-панели (CRM) для загрузчика DeviantArt

Bounded context: **photomanager** (DeviantArt uploader).

Документ описывает поэтапный план добавления простой админ-панели, которая
позволит из CRM:

- видеть изображения, лежащие в папке `UPLOAD_DIR`;
- настраивать для каждого файла, нужно ли его:
  - сразу публиковать в галерею DeviantArt; или
  - загружать только в Stash (без публикации);
- запускать процесс загрузки по уже сохранённым настройкам.

Все шаги опираются на существующую архитектуру (DDD, сервисы/репозитории, HttpClient).

---

## 1. Цели и границы

**Цель MVP админки** — одна простая страница в CRM, с которой можно:

1. Просмотреть список файлов-изображений из папки `upload/`.
2. Для каждого файла указать:
   - заголовок (title);
   - режим загрузки:
     - «сразу публиковать» (`publish_immediately`),
     - «только Stash» (`stash_only`).
3. Сохранить эти настройки в локную БД (таблица `deviations`).
4. Отдельной кнопкой запустить загрузку всех «запланированных» девиаций.

**Вне рамок MVP** (но возможно позже):

- выбор галереи из списка (`gallery_id`);
- настройка тегов, mature/AI флагов и прочих параметров;
- пагинация, поиск, фильтрация;
- полноценная аутентификация/авторизация в самой CRM.

---

## 2. Архитектурные принципы

- **DDD, SOLID, KISS** — как и в остальной системе.
- **Три слоя:**
  - Domain — только модели (`Deviation`, `UploadStatus` и т.д.).
  - Storage — PostgreSQL + репозитории (без HTTP).
  - Service — бизнес-логика + HTTP к DeviantArt.
- **Никакого HTTP/UI кода в домене и репозиториях.**
- **Интеграция с CRM** через чёткий API-контракт (JSON DTO), либо через
  прямой вызов сервисов, если CRM живёт в одном процессе.
- **Никакого прямого `os.getenv` и логгера вне уже существующих точек** —
  использовать `Settings`/`get_settings()` и `setup_logger()`.

---

## 3. Функциональные требования MVP

1. **Просмотр кандидатов на загрузку**
   - Источник: файловая система (`Settings.upload_dir`).
   - Фильтр: поддерживаемые расширения (`.jpg`, `.jpeg`, `.png`, `.gif`, `.bmp`).
   - Для каждого файла отдаём:
     - `filename`;
     - относительный или абсолютный путь для превью;
     - размер файла (опционально);
     - уже сохранённые настройки (если в БД есть `Deviation` с таким `filename`).

2. **Редактирование настроек перед загрузкой**
   - Для каждого файла можно задать:
     - `title` (по умолчанию — имя файла без расширения);
     - флаг `publish_immediately: bool`;
     - флаг `stash_only: bool` (взаимоисключимо с `publish_immediately`).
   - Нажатие «Сохранить» записывает/обновляет соответствующие `Deviation` в БД
     со статусом `NEW`/`READY`.

3. **Запуск загрузки**
   - Кнопка «Загрузить запланированные».
   - Бэкенд выбирает из БД откладываемые `Deviation` нужного статуса и
     выполняет для них стандартный процесс загрузки (`StashClient` + `PublishClient`).

---

## 4. Изменения в доменной модели и БД

> Важно: конкретная миграция может быть реализована отдельной задачей.
> Здесь только план.

1. **Расширение `Deviation` в `src/domain/models.py`**

   Добавить поля поведения для админки:

   - `publish_immediately: bool = True`
   - `stash_only: bool = False`

   Инварианты (логика будет в сервисном слое):

   - если `publish_immediately` установлено в `True`, то `stash_only` должно быть `False`;
   - если `stash_only` установлено в `True`, то `publish_immediately` — `False`.

2. **Расширение схемы БД (`src/storage/database.py`)**

   - В таблицу `deviations` добавить два поля:
     - `publish_immediately INTEGER NOT NULL DEFAULT 1`,
     - `stash_only INTEGER NOT NULL DEFAULT 0`.
   - Добавить соответствующую миграцию в `_migrate_database`.

3. **Адаптация `DeviationRepository`**

   - В `INSERT INTO deviations (...)` и `UPDATE deviations SET ...`:
     - добавить сохранение/обновление `publish_immediately` и `stash_only`.
   - В маппинге `row -> Deviation` (методы `get_*`) добавить чтение этих полей
     и преобразование `0/1 -> bool`.

---

## 5. Сервисный слой для планирования загрузок

### 5.1. DTO для настроек файлов

Создать простой DTO (dataclass) в сервисном слое, например
`src/service/dto.py`:

- `FileUploadSettings`:
  - `filename: str`
  - `title: str | None`
  - `publish_immediately: bool`
  - `stash_only: bool`

Этот класс **не** должен знать ни про HTTP, ни про БД.

### 5.2. Метод планирования в `UploaderService`

Добавить в `UploaderService` метод-оркестратор (без изменения существующего
публичного поведения):

```python
def plan_uploads_for_files(self, files: list[FileUploadSettings]) -> None:
    """Создать/обновить Deviation для файлов по настройкам из админки."""
```

Алгоритм:

1. Для каждого `FileUploadSettings`:
   - проверить, есть ли уже запись в БД
     (`DeviationRepository.get_deviation_by_filename(filename)`);
   - если есть — обновить заголовок и флаги поведения (`publish_immediately`, `stash_only`),
     сбросить статус в `NEW` при необходимости;
   - если нет — создать `Deviation` через существующий метод
     `create_deviation_from_file`, подставить заголовок и флаги поведения.
2. Сохранить/обновить `Deviation` в БД.

### 5.3. Метод запуска запланированных загрузок

Добавить в `UploaderService` метод, который будет вызываться из CRM/CLI:

```python
def upload_planned(self) -> dict:
    """Загрузить все запланированные девиации и вернуть статистику."""
```

Алгоритм:

1. Запросить из БД список `Deviation` со статусом `NEW` (и, при необходимости,
   дополнительным фильтром по флагам поведения).
2. Для каждой девиации:
   - обеспечить аутентификацию через `AuthService` (по аналогии с `upload_deviation`);
   - вызвать стандартный пайплайн загрузки:
     - если `stash_only` — выполнить только шаг `StashClient.upload_to_stash`
       (без publish) и завершить со статусом `DONE` или `FAILED`;
     - если `publish_immediately` — выполнить полный pipeline
       (Stash + publish).
3. Обновить статусы в БД и вернуть агрегированную статистику
   (`total`, `successful`, `failed`).

> Примечание: реализация может переиспользовать уже существующий
> `upload_deviation`, если его скорректировать с учётом новых флагов.

---

## 6. API-контракт между бэкендом и CRM

В зависимости от того, где живёт CRM, есть два варианта:

1. **CRM в том же Python-процессе** — CRM код напрямую вызывает методы
   сервисов (`UploadScanner`, `UploaderService.plan_uploads_for_files`,
   `UploaderService.upload_planned`).
2. **CRM как отдельное веб-приложение** — сделать тонкий HTTP-слой (например,
   на FastAPI/Flask/Django), который просто делегирует в уже существующие
   сервисы.

Ниже — вариант для HTTP API (его можно использовать как внутренний
контракт, даже если реализация будет в другом репозитории).

### 6.1. Получение списка файлов-кандидатов

- `GET /api/uploads/candidates`

Ответ (JSON):

```json
[
  {
    "filename": "art1.png",
    "relative_path": "upload/art1.png",
    "size": 123456,
    "title": "art1",
    "publish_immediately": true,
    "stash_only": false
  }
]
```

Источники данных:

- список файлов — через `UploadScanner`;
- существующие настройки — через `DeviationRepository.get_deviation_by_filename`.

### 6.2. Сохранение настроек для списка файлов

- `POST /api/uploads/plan`

Тело запроса (JSON):

```json
[
  {
    "filename": "art1.png",
    "title": "Мой арт 1",
    "publish_immediately": true,
    "stash_only": false
  },
  {
    "filename": "art2.png",
    "title": "Эскиз",
    "publish_immediately": false,
    "stash_only": true
  }
]
```

Действия на бэкенде:

- маппинг JSON -> `FileUploadSettings`;
- вызов `UploaderService.plan_uploads_for_files(...)`;
- возврат 200 OK / 400 с описанием ошибок валидации.

### 6.3. Запуск загрузки запланированных

- `POST /api/uploads/run`

Ответ (JSON):

```json
{
  "total": 10,
  "successful": 8,
  "failed": 2
}
```

Действия на бэкенде:

- вызов `UploaderService.upload_planned()`;
- возврат статистики.

---

## 7. Минимальный UI для CRM (одна страница)

Макет страницы (независимо от фреймворка):

1. **Таблица/список файлов**
   - Колонки:
     - «Превью» (опционально, `<img src="/upload/<filename>" />` или через отдельный эндпоинт);
     - «Файл» (`filename`);
     - «Заголовок» (`<input type="text">`);
     - `[ ] Публиковать сразу` (`publish_immediately`);
     - `[ ] Только Stash` (`stash_only`).
2. **Кнопки действий**
   - «Сохранить настройки» → `POST /api/uploads/plan`.
   - «Запустить загрузку» → `POST /api/uploads/run`.
3. **Отображение статуса**
   - после `run` показать статистику (`total`, `successful`, `failed`).

Правила UI:

- при установке `publish_immediately` автоматически снимать `stash_only` и наоборот;
- подсвечивать строки с уже существующими девиациями (опционально);
- предусмотреть простое сообщение об ошибках (валидация, сетевые ошибки).

---

## 8. Тестирование

1. **Unit-тесты для нового поведения доменной модели и репозитория**
   - `tests/test_domain_models.py` — добавить проверки новых полей
     `publish_immediately`, `stash_only` и инвариантов.
   - Новый файл `tests/test_deviation_repository.py` — сохранить/прочитать
     `Deviation` с разными комбинациями флагов.

2. **Unit-тесты для планирующих методов `UploaderService`**
   - использовать тестовую БД Postgres (например, в docker);
   - замокать `AuthService`, `StashClient`, `PublishClient`, `FileMover`;
   - проверить, что:
     - новые девиации создаются для файлов без записей в БД;
     - существующие откладываемые девиации обновляются без дублирования;
     - флаги поведения учитываются при выборе сценария загрузки.

3. **Интеграционные тесты HTTP-слоя (если он будет в этом же репозитории)**
   - для `/api/uploads/candidates` — корректный возврат списка файлов;
   - для `/api/uploads/plan` — валидация и запись в БД;
   - для `/api/uploads/run` — корректная агрегация статистики.

Цель по покрытию: сохранить/достичь ≥85% (`pytest --cov=src`).

---

## 9. Этапы реализации по шагам

1. **Подготовка домена и БД**
   - [ ] Добавить поля `publish_immediately`, `stash_only` в `Deviation`.
   - [ ] Реализовать миграцию в `database.py`.
   - [ ] Обновить `DeviationRepository` под новые поля.
   - [ ] Добавить/обновить тесты домена и репозитория.

2. **Сервисное планирование**
   - [ ] Ввести `FileUploadSettings` (DTO).
   - [ ] Реализовать `UploaderService.plan_uploads_for_files`.
   - [ ] Реализовать `UploaderService.upload_planned` (или скорректировать
         `process_uploads` для повторного использования).
   - [ ] Покрыть эти методы тестами с использованием моков.

3. **API-контракт для CRM**
   - [ ] Уточнить, где живёт CRM (тот же сервис/другой проект).
   - [ ] Определить, будет ли HTTP-слой реализован в этом репозитории.
   - [ ] Если да — добавить минимальный web-слой (FastAPI/Flask) с тремя
         эндпоинтами: `GET /api/uploads/candidates`, `POST /api/uploads/plan`,
         `POST /api/uploads/run`.

4. **UI в CRM**
   - [ ] Реализовать страницу списка файлов с формой редактирования.
   - [ ] Подключить вызовы к API (`candidates`, `plan`, `run`).
   - [ ] Добавить простую индикацию прогресса и ошибок.

5. **Финальная проверка**
   - [ ] Прогнать `pytest --cov=src --cov-report=term-missing`.
   - [ ] Прогнать линтеры: `black`, `isort`, `flake8`.
   - [ ] Протестировать руками основной сценарий:
     - файл лежит в `upload/` → отображается в админке;
     - настраиваются галочки и заголовок → сохраняются в БД;
     - запускается загрузка → файл оказывается в DeviantArt/ Stash и
       перемещается в `upload/done`.
