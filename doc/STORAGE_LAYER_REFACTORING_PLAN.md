# План рефакторинга уровня хранения

**Дата**: 24.12.2025
**Статус**: Планирование
**Цель**: Сокращение дублирования на уровне хранения (репозитории + адаптеры +
инструменты для работы со схемами) при сохранении границ «репозиторий на сущность».

---

## Краткое изложение

Обзор уровня хранения показывает повторяющиеся вспомогательные функции выполнения
SQLAlchemy Core, вставку идентификаторов и логику очередей/статистики журналов в
нескольких репозиториях. Также наблюдается дублирование в инициализации схемы и
остаточные ссылки на SQLite (хотя бэкенд теперь только PostgreSQL). Этот план
объединяет общее поведение хранилища в базовых абстракциях и утилитах реестра, не
нарушая правило «один репозиторий на сущность» и без изменения бизнес-логики.

Ожидаемый результат: меньшее количество повторяющихся вспомогательных функций
выполнения, единый реестр схем и PostgreSQL-only конфигурация без SQLite при
сохранении API репозиториев.

---

## Область применения (не только репозитории)

В этот план включено:
- Репозитории в `src/storage/*_repository.py`
- Абстракции базы данных хранилища (`base_repository.py`)
- Фабрика баз данных (`database.py`) и точка входа пакета хранилища (`__init__.py`)
- Адаптеры (`src/storage/adapters/*`)
- Модули схемы/метаданных (`models.py`, `*_tables.py`)
- Обертки совместимости (`stats_repository.py`)
- Документация по хранилищу (README*.md, `doc/drafts/*`)

---

## Выявлены дублирующиеся шаблоны кода

### 1) Вспомогательные функции `_execute_core()`/`_scalar()` повторяются в нескольких репозиториях

Шаблон: методы `_execute_core()` + `_scalar()` реализованы локально с
немного отличающимися проверками соединения.

Обнаружено в 9 репозиториях:
- `feed_deviation_repository.py`
- `deviation_comment_log_repository.py`
- `deviation_comment_message_repository.py`
- `deviation_comment_queue_repository.py`
- `deviation_comment_state_repository.py`
- `profile_message_repository.py`
- `profile_message_log_repository.py`
- `profile_message_queue_repository.py`
- `watcher_repository.py`

Влияние: повторяющаяся логика (~15-30 строк на репозиторий) и непоследовательная обработка
оберток DBConnection по сравнению с необработанными соединениями.

---

### 2) Повторное получение идентификатора вставки в разных репозиториях

Шаблон: проверка `inserted_primary_key`, затем возврат к `last_insert_rowid()`.

Обнаружено в:
- `deviation_comment_log_repository.py`
- `deviation_comment_message_repository.py`
- `profile_message_log_repository.py`
- `profile_message_repository.py`
- `profile_message_queue_repository.py`

Влияние: повторяющийся код и смешанные предположения о PostgreSQL/SQLite в путях, предназначенных только для PG.

---

### 3) Повторный подсчет статистики очереди/журнала

Шаблон: `get_stats()` / `get_queue_count()` с идентичными запросами подсчета.

Обнаружено в:
- `feed_deviation_repository.py` (ожидающие/отмеченные/неудачные/всего)
- `deviation_comment_queue_repository.py` (ожидающие/комментированные/неудачные/всего)
- `profile_message_log_repository.py` (отправленные/неудачные/всего)
- `profile_message_queue_repository.py` (подсчет по статусу)

Влияние: повторяющаяся логика подсчета и повторяющийся резервный вариант `_scalar`.

---

### 4) Шаблон фиксации после записи повторяется повсюду

Шаблон: оператор execute, затем `self.conn.commit()` в каждом репозитории.

Влияние: повторяющийся шаблонный код и непоследовательная обработка ошибок.

---

### 5) Дублирование списка инициализации схемы в адаптере

Шаблон: SQLAlchemyAdapter вручную создает:
- `Base.metadata`
- `feed_metadata`
- `profile_message_metadata`
- `deviation_comment_metadata`

Последствия: всякий раз, когда добавляются новые метаданные Core, их необходимо регистрировать вручную
здесь; легко пропустить и дублировать управление списками.

---

### 6) Остаточные ссылки на SQLite в коде и документации

Примеры:
- Докстринги и комментарии (`BaseRepository`, `DatabaseAdapter`,
  `SQLAlchemyAdapter`, `models.py`)
- `storage/__init__.py` и README (упоминание `DATABASE_TYPE=sqlite`)
- `sqlite_adapter.py` содержит мертвый код после `raise`
- В репозиториях есть ветки `last_insert_rowid()` и SQLite-совместимые комментарии

Последствия: вводит в заблуждение и оставляет "мертвые" пути выполнения.

---

## План рефакторинга

### Этап 1: Объединение вспомогательных функций выполнения ядра в BaseRepository

**Цель**: устранить повторяющиеся `_execute_core()` / `_scalar()` и нормализовать обработку
DBConnection.

Предлагаемые дополнения к `BaseRepository`:
- `_execute_core(statement, parameters=None)` (или использование уже существующего
  `_execute` без локальных копий)
- `_scalar_core(statement, parameters=None)` (или использование уже существующего
  `_scalar`)
- `_fetchone(statement, parameters=None)`
- `_fetchall(statement, parameters=None)`
- `_execute_and_commit(statement, parameters=None)`
- `_rowcount(result)` для унификации обработки `rowcount`

**Влияние**:
- Удаление локальных вспомогательных функций из 9 репозиториев, перечисленных выше.

- Стандартизация обработки соединений и поведения при ошибках.

---

### Этап 2: Добавление вспомогательной функции Insert-ID

**Цель**: устранение повторяющейся логики `inserted_primary_key` + `last_insert_rowid()`.

Добавление базовой вспомогательной функции:
- `_insert_returning_id(insert_stmt, returning_col=None)`

**Влияние**:
- Обновление всех хранилищ логов/сообщений/очередей для использования одной
  вспомогательной функции.
- Переход на `insert().returning()` (PostgreSQL-only) и удаление веток
  `last_insert_rowid()`.

---

### Этап 3: Введение базовых абстракций очередей/логов

**Цель**: стандартизация статистики очередей/логов и шаблонов удаления при сохранении
отдельных хранилищ для каждой сущности.

Добавлены базовые классы:
- `BaseQueueRepository` (статистика очереди, очистка, подсчет, обновления статуса)
- `BaseLogRepository` (вспомогательные функции get_stats, list, count)

**Влияние**:
- `feed_deviation_repository.py`
- `deviation_comment_queue_repository.py`
- `profile_message_queue_repository.py`
- `profile_message_log_repository.py`
- `deviation_comment_log_repository.py`

---

### Этап 4: Реестр схем для инициализации адаптера

**Цель**: централизовать все метаданные SQLAlchemy, чтобы избежать отсутствия таблиц.

Добавить `src/storage/schema_registry.py`:
- `CORE_METADATA = [feed_metadata, profile_message_metadata, deviation_comment_metadata, ...]`
- `ORM_METADATA = Base.metadata`

Обновить `SQLAlchemyAdapter.initialize()` для итерации по реестру.

---

### Этап 5: Удаление остатков SQLite (PostgreSQL-only)

**Цель**: полностью вычистить оставшиеся упоминания SQLite и мертвые ветки кода.

Подзадачи:
- Удалить SQLite-комментарии и fallback-ветки (`last_insert_rowid()`,
  "for SQLite") в репозиториях.
- Упростить `sqlite_adapter.py` (оставить только явный `raise`, без мертвого
  кода) либо удалить модуль и все импорты/ссылки на него.
- Обновить докстринги и комментарии (`BaseRepository`, `DatabaseAdapter`,
  `SQLAlchemyAdapter`, `models.py`, `storage/__init__.py`) на PostgreSQL-only.
- Обновить документацию (`README.md`, `README_RU.md`, `doc/drafts/*`) и убрать
  `DATABASE_TYPE=sqlite`.

---

### Этап 6: Очистка обертки совместимости

`stats_repository.py` — это фасад для специализированных репозиториев.

Варианты:
- Сохранить, но пометить как устаревший и обновить документацию.

- Удалить и обновить все точки вызова для использования конкретных репозиториев.

---

### Этап 7: Тесты

Добавление/расширение тестов для:
- Вспомогательных методов BaseRepository
- Базовых абстракций очереди/журнала
- Реестра схем и инициализации SQLAlchemyAdapter
- Поведения, возвращаемого при вставке для PostgreSQL

---

## Критерии успеха

- Повторяющиеся `_execute_core/_scalar` удалены из репозиториев
- Использование единого реестра схем при инициализации адаптера
- Отсутствуют остаточные упоминания SQLite и мертвые ветки в коде/документации
- Отсутствие SQL на уровне сервисов; репозитории остаются для каждой сущности
- Тесты обновлены для новых абстракций

---
